# 調査蓄積

調べたことをどんどん蓄積していきます。

## リトルエンディアンとビッグエンディアン

SEARCH: BigEndian, LittleEndian

私が勘違いしていたことも含めて。

[参考資料: 「ビッグエンディアン」と「リトルエンディアン」の違い](https://wa3.i-3-i.info/diff112endiannes.html)

- ビッグエンディアン
  - データをバイト単位で配置する際のやり方のひとつで「最初のバイトからデータを並べる」やり方
- リトルエンディアン
  - データをバイト単位で配置する際のやり方のひとつで「最後のバイトからデータを並べる」やり方

例

```text
例えば4バイトのデータ「00000001 00000010 00000100 00001000」があったとします。

このデータを（例えばメモリ上に）並べて置く際には

ビッグエンディアンは以下のように並べて置く方法です。

1つめ：00000001（1バイト目）
2つめ：00000010（2バイト目）
3つめ：00000100（3バイト目）
4つめ：00001000（4バイト目）

リトルエンディアンは以下のように並べて置く方法です。

1つめ：00001000（4バイト目）
2つめ：00000100（3バイト目）
3つめ：00000010（2バイト目）
4つめ：00000001（1バイト目）
```

x6, x86_64はリトルエンディアンである。ARMはどちらも切り替えが可能とのこと。iOSもAndroidもリトルエンディアンなので、企保編的には「通常のコンピュータはリトルエンディアン」だと思っておいてよい。

さらに例。

以下のプログラムは、実験。BigEndianとLittleEndianの違いを確認する。

```go
// big / little endian test
package main

import (
    "bytes"
    "encoding/binary"
    "fmt"
)

func main() {
    // 32ビットのビッグエンディアンのデータ (10000)
    data := []byte{0x00, 0x00, 0x27, 0x10}
    var i int32
    // エンディアンの変換
    binary.Read(bytes.NewReader(data), binary.BigEndian, &i)
    fmt.Printf("BigEndian data: %d\n", i)
    // リトルエンディアンに変換 数値がおかしくなる
    binary.Read(bytes.NewReader(data), binary.LittleEndian, &i)
    fmt.Printf("Little Endian data: %d\n", i)
}
```

出力

```text
BigEndian data: 10000
Little Endian data: 270991360
```

- 勘違いしていた部分
  - CPUには二種類あり、BigEndianとLittleEndianの処理系があるため、BigなCPUには、Read関数でBigEndianを渡す必要があり、Littleのほうも然り、と思っていた。
  - データとしての持ち方、と、CPUの処理系について、混同していたことになる。
  - 「エンディアンとは、データがどのように格納されているか」を示すものであって、CPUの処理系とは関係ない。

データは、`data := []byte{0x00, 0x00, 0x27, 0x10}`のように゛「ビッグエンディアン」として持っているので、binary.Readには「このデータはビッグエンディアンである」とbinary.BigEndianを引数で渡して宣言してあげるだけ。

なんか釈然としなかったので、いろいろともじもじしていたのだが、調査して整理できた。

いろいろとChatGPTに質問してみたが、結論は以下。

```text
「勘違いしてました。
ビッグエンディアンであるデータをリトルエンディアンのCPUで取り扱うときは、Readの引数にLittleEndianを渡さなきゃならないと思っていました。それだとかなりCPUの処理の違いをきにしないといけないですが、このデータは、これである、を渡すだけなら、データがbigなのかlittleなのかがわかってさえいればよい、ということですね。」

そうです！🎯 CPUのエンディアンは関係なく、「このデータがどのエンディアンで格納されているのか？」を指定するだけでOK です！

勘違いしやすいポイント ですが、気づいた通り、CPUがリトルエンディアンだからといって binary.LittleEndian を渡さなきゃいけないわけではありません。

大事なのは、「データがどのエンディアンで保存されているか？」だけ です。
CPUがリトルエンディアンでも、ビッグエンディアンのデータなら binary.BigEndian を渡せば 正しく解釈 できます。
```

## ほかのコンソールで使われているファイルディスクリプタが分捕れなかった理由

例えば、ある長時間かかるジョブAの処理をlinuxサーバーで実行していたとして、ジョブAのログをsshコンソールで出力していたとする。

で、ネットワーク瞬断等でそのジョブAのログ出力しているコンソールが途切れたとする。

linuxは `/proc/{pid}/fd` 以下にファイルディスクリプタがあるので、そのファイルディスクリプタを使って、途切れたコンソールを別のコンソールから引き継ぐことができるのでは、と思って、別のコンソールBから

```sh
cat /proc/{pid}/fd/1
```

やら

```sh
tail -f /proc/{pid}/fd/1
```

やらをしてみたのだが、できなかった。

最近はやりのdeepseekで調べてみた。

ttyやptsが何者かいろいろ調べ、ファイルディスクリプタについても調べ、下記の質問に至る。

```text
「/ptoc/{pid}/fd/1 が端末（pts）につながっている場合、そのファイルディスクリプタを直接読み取ることができない理由は何ですか？」


はい、/proc/<pid>/fd/1 がまだ端末（pts）につながっている場合、直接そのファイルを読み取っても何も表示されないか、またはエラーが発生します。これは、端末に直接出力されているデータは、/proc/<pid>/fd/1 を介して直接読み取ることができないためです。

なぜ読み取れないのか？
端末（pts）の特性: 端末に出力されるデータは、カーネルによって管理されており、通常のファイルのように直接読み取ることができません。

ファイルディスクリプタの状態: /proc/<pid>/fd/1 が pts を指している場合、そのファイルディスクリプタを読み取ろうとしても、端末に出力されたデータはバッファに残らず、直接端末に送信されます。
```

うまく理解できなかったのだが、つまり、あるfdがpts0につながっている状態(冒頭のジョブAの話)で、別の端末pts1からそのfdを読み取ろうとしても、そのfdはpts0につながっているので、読み取れない、ということか。

読み取るには、`dup2` 等のシステムコールを使用して、fd->pts0からfd->pts1に「付け替える」必要がある、という理解でよさそう。

この辺りは、ChatGPT先生いわく、以下のポイントで学習するとよいらしい。

```text
【学習のポイント】
リダイレクトを理解するために重要なのは、**ファイルディスクリプタ** がどのように動作し、プロセスがどこに出力を送っているのかを知ることです。具体的なポイントは以下の通りです：

1. **ファイルディスクリプタの概念**
   - ファイルディスクリプタがどのように標準入力（`stdin`）、標準出力（`stdout`）、標準エラー出力（`stderr`）に関連付けられているかを理解する。
   
2. **リダイレクトの操作**
   - `>`（標準出力リダイレクト）や `<`（標準入力リダイレクト）を使うと、シェルがどうやってファイルディスクリプタを変更するのかを知る。
   - プログラム内で `dup2` や `dup` を使って、出力先や入力先をどのように変更するかを学ぶ。

3. **システムコールを通じたリダイレクト**
   - `dup2` や `fcntl` を使ってファイルディスクリプタを複製したり、変更したりする方法を学ぶ。

【結論】
リダイレクトを学ぶと、シェルやプログラム内での標準出力・標準入力の変更方法がよく理解できるようになります。`dup2` や `dup` を使ったファイルディスクリプタの操作が実際にどのように行われるのかも、リダイレクトの概念を理解することで、より深く理解できるようになりますよ！
```

## システムコールについて

linuxのmanページを見ると、システムコールは `dup2` ([ubuntu systemcall manpage](https://manpages.ubuntu.com/manpages/focal/ja/man2/syscalls.2.html))のように定義されているが、実際のカーネルのソースコードだと以下のようになっている。

linux v6.13 systemcall [dup2 Header](https://github.com/torvalds/linux/blob/ffd294d346d185b70e28b1a28abe367bbfe53c04/include/linux/syscalls.h#L1046)

`sys_dup2` のようにプレフィックスで `sys_` がついている。

manページには、`dup2` と書かれているので、おそらく各言語のシステムコールを扱うライブラリ(c: glibc, go: syscallパッケージ)が、`dup2` という名前でラップしているのだろう。

goで調べてみた。

<https://github.com/golang/go/blob/d04e3cbc9240e25de449dcae2ec33d03062f347b/src/syscall/zsyscall_linux_amd64.go#L1089>

```go
func Dup2(oldfd int, newfd int) (err error) {
    _, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)
    if e1 != 0 {
        err = errnoErr(e1)
    }
    return
}
```

`SYS_DUP2` という定数は以下の場所で定義。

<https://github.com/golang/go/blob/d04e3cbc9240e25de449dcae2ec33d03062f347b/src/syscall/zsysnum_linux_amd64.go#L42>

```go
    SYS_SHMCTL                 = 31
    SYS_DUP                    = 32
    SYS_DUP2                   = 33
    SYS_PAUSE                  = 34
    SYS_NANOSLEEP              = 35
```

上記のソースはamd64アーキテクチャのもので、例えば、386アーキテクチャのものは以下。

<https://github.com/golang/go/blob/d04e3cbc9240e25de449dcae2ec33d03062f347b/src/syscall/zsysnum_linux_386.go#L72>

```go
    SYS_CHROOT                 = 61
    SYS_USTAT                  = 62
    SYS_DUP2                   = 63
    SYS_GETPPID                = 64
    SYS_GETPGRP                = 65
```

処理系によってシステムコールの番号が違う、というわけだ。

システムコール自体は `zsyscall_linux*.go` ファイルに定義されていて、そこから呼ばれている定数は `zsysnum_linux_*.go` に定義されている。
